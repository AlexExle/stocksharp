namespace StockSharp.Algo.Testing
{
	using StockSharp.BusinessEntities;
	using StockSharp.Messages;

	/// <summary>
	/// Базовое подключение эмуляции.
	/// </summary>
	public abstract class BaseEmulationConnector : Connector
	{
		/// <summary>
		/// Инициализировать <see cref="BaseEmulationConnector"/>.
		/// </summary>
		protected BaseEmulationConnector()
		{
			var adapter = new EmulationMessageAdapter(new MarketEmulator(), TransactionIdGenerator);
			Adapter.InnerAdapters.Add(adapter.ToChannel(this));
		}

		/// <summary>
		/// Поддерживается ли перерегистрация заявок через метод <see cref="IConnector.ReRegisterOrder(StockSharp.BusinessEntities.Order,StockSharp.BusinessEntities.Order)"/>
		/// в виде одной транзакции.
		/// </summary>
		public override bool IsSupportAtomicReRegister
		{
			get { return MarketEmulator.Settings.IsSupportAtomicReRegister; }
		}

		/// <summary>
		/// Эмулятор торгов.
		/// </summary>
		public IMarketEmulator MarketEmulator
		{
			get { return ((EmulationMessageAdapter)TransactionAdapter).Emulator; }
			set { ((EmulationMessageAdapter)TransactionAdapter).Emulator = value; }
		}

		/// <summary>
		/// Запустить таймер генерации сообщений <see cref="TimeMessage"/> с интервалом <see cref="Connector.MarketTimeChangedInterval"/>.
		/// </summary>
		protected override void StartMarketTimer()
		{
		}

		///// <summary>
		///// Обработать сообщение, содержащее рыночные данные.
		///// </summary>
		///// <param name="message">Сообщение, содержащее рыночные данные.</param>
		///// <param name="direction">Направление сообщения.</param>
		//protected override void OnProcessMessage(Message message, MessageDirections direction)
		//{
		//	if (adapter == MarketDataAdapter && direction == MessageDirections.Out)
		//	{
		//		switch (message.Type)
		//		{
		//			case MessageTypes.Connect:
		//			case MessageTypes.Disconnect:
		//			case MessageTypes.MarketData:
		//			case MessageTypes.Error:
		//			case MessageTypes.SecurityLookupResult:
		//			case MessageTypes.PortfolioLookupResult:
		//				base.OnProcessMessage(message, direction);
		//				break;

		//			case MessageTypes.Execution:
		//			{
		//				var execMsg = (ExecutionMessage)message;

		//				if (execMsg.ExecutionType != ExecutionTypes.Trade)
		//					SendInMessage(message);
		//				else
		//					base.OnProcessMessage(message, direction);

		//				break;
		//			}

		//			default:
		//				SendInMessage(message);
		//				break;
		//		}
		//	}
		//	else
		//		base.OnProcessMessage(message, direction);
		//}
	}
}